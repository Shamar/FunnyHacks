using System;
using Oven;
using Epic;
using System.Runtime.Serialization;

namespace iOven.Autogenerated
{
    [Serializable]
    internal sealed class ControlledOvenProxy : Oven.Control.IOven, ISerializable
    {
        private readonly OvenUri _uri;
        private readonly IServer _server;
		private readonly Oven.Control.IOven _local; 
        internal ControlledOvenProxy (OvenUri uri, IServer server)
        {
            _uri = uri;
            _server = server;
            _local = _server.Read(new ReadOvenLocalCopy(_uri));
			_local.Syncronizing += (sender, e) => FireEvent(Syncronizing, e);
			_local.Forgetting += (sender, e) => FireEvent(Forgetting, e);
			_local.CookingAdjusted += (sender, e) => FireEvent(CookingAdjusted, e);
			_local.Cooked += (sender, e) => FireEvent(Cooked, e);
        }
		
        private void FireEvent<TEventArgs>(EventHandler<TEventArgs> handler, TEventArgs arg)
            where TEventArgs : EventArgs
        {
            if(null != handler)
                handler(this, arg);
        }
		
		private static OvenUri DeserializeUri(SerializationInfo info)
		{
			return new OvenUri(info.GetString("u"));
		}
		
		private static IServer DeserializeServer(SerializationInfo info)
		{
			return (IServer)info.GetValue("s", typeof(IServer));
		}
		
		protected ControlledOvenProxy (SerializationInfo info, StreamingContext context)
			: this(DeserializeUri(info), DeserializeServer(info))
		{
		}

        #region IOven implementation
        public OvenUri Address {
            get {
                return _uri;
            }
        }
        #endregion

        #region IOven implementation
        public event EventHandler<InfoEventArgs<TimerId>> Syncronizing;

		public event EventHandler<InfoEventArgs<TimerId>> Forgetting;

        public event EventHandler<Oven.Control.CookingEventArgs> CookingAdjusted;

        public event EventHandler<InfoEventArgs<Time>> Cooked;

        public void CookFor (Minute duration, Temperature desiredTemperature)
        {
            throw new NotImplementedException ();
        }

        public void StopCooking ()
        {
            throw new NotImplementedException ();
        }
				
		
		public void Forget (ITimer timer)
		{
			throw new NotImplementedException ();
		}

        public void Syncronize (ITimer timer)
        {
            throw new NotImplementedException ();
        }

        public void AlertThrough (Oven.Control.IAlarmBell alarm)
        {
            throw new NotImplementedException ();
        }

        public bool IsCooking {
            get {
                return _local.IsCooking;
            }
        }

        public Temperature CurrentTemperature {
            get {
                return _local.CurrentTemperature;
            }
        }

        public Time? PlannedStop {
            get {
                return _local.PlannedStop;
            }
        }

        public System.Collections.Generic.IEnumerable<TimerId> SycronizedTimers {
            get {
                throw new NotImplementedException ();
            }
        }
        #endregion

		#region ISerializable implementation
		void ISerializable.GetObjectData (SerializationInfo info, StreamingContext context)
		{
			info.AddValue("u", _uri.ToString());
			info.AddValue("s", _server, typeof(IServer));
		}
		#endregion
    }
}

